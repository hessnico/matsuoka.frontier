---
title: "MatsuokaDistribution"
output: rmarkdown::html_vignette
description: Learn how to use "MatsuokaDistribution" class object to estimate the production frontier
vignette: >
  %\VignetteIndexEntry{MatsuokaDistribution}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}

---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Summary

In this vignette there will be shown cases of use of `matsuoka.frontier` package usage

1. Pre-mounted `g(.)` estimation methods
2. Method with specific arguments
3. Method with custom `g(.)` estimative
4. Without using the wrapper `matsuoka3step`

## Setup for package use

```{r setup}
devtools::load_all()
library(matsuoka.frontier)
library(ggplot2)
library(Benchmarking)

data(milkProd)

N=nrow(milkProd)                #N=108
nc=milkProd$cows                #n cows
xc1=milkProd$vet/nc             #vet. expenses per cow (X)
x1=(xc1-min(xc1))/(max(xc1)-min(xc1))   #normalization 
xc2=milkProd$energy/nc          #energy expenses per cow (X)
x2=(xc2-min(xc2))/(max(xc2)-min(xc2))   #normalization
X=cbind(x1,x2)

y <- milkProd$milk/nc/10^3 
```

## Pre-mounted `g(.)` estimation methods

```{r premounted}
x.df <- as.data.frame(X)
res <- matsuoka.frontier::matsuoka3step(x = x.df, y = y, g = "gam")
```

This generates the `matsuoka3step` class object.
Please Check the documentation for more infomation with `help(matsuoka3step)`.

The default non-parametric function that estimates `g(.)` is set to the `gam` function.
It's possible to diagnose the `g(.)` function estimation through hierarchical built-in functions.

For example, the diagnose the default parameter `g(.)` function estimation can be done using `summary` and `plot`. This works, because `gam` has this built-in in it's class.

For example:
```{r gam diagnose}
summary(
  res$g_hat$fn_obj
)

plot(
  res$g_hat$fn_obj
)
```

After diagnosing the `g(.)` function, we can forward to the production frontier estimation diagnostics.
There is a built-in plot function that can be used, for example:
```{r gam mat}
plot(res)
plot(res, ngrid = 200, counter_levels = 15)
plot(res, ngrid = 300, counter_levels = 8, xlab = "vet/cow", ylab = "energy/cow")
```

And also a summary built-in function that provides further insights on the estimation, such as efficiency scores and percentage of efficiency stoces higher than one...
```{r}
summary(res)
```

## Method with specific arguments

The `matsuoka3step` estimation function inherits properties from S3 objects, such as three dots that can be used for the estimation of `g(x)`.

```{r specific}
res.specific.gam <- matsuoka.frontier::matsuoka3step(x = x.df, y = y, g = "gam",
                                        family = "gaussian",
                                        method = "NCV",
                                        optimizer = "efs")
summary(res.specific.gam)

res.specific.spline <- matsuoka.frontier::matsuoka3step(x = as.data.frame(x.df$x1),
                                                        y = y, g ="spline",
                                                        lambda = 5,
                                                        all.knots = TRUE,
                                                        penalty = 0.95)

summary(res.specific.spline)
```

## Method with custom `g(.)` estimative

Finally, there's the possibility to apply a customizable function from the user

```{r custom}
custom_fun <- function(X, z, ...) {
    list(estimate = rep(mean(z), nrow(X)))
}

res.custom.fn <- matsuoka.frontier::matsuoka3step(x = x.df, y = y, g = custom_fun)
summary(res.custom.fn)
plot(res.custom.fn)
```

## Without using the wrapper `matsuoka3step`

There's also the possibility to mount your own matsuoka three step approach, given that primary functions are being publicly exported

```{r diy}
diy.df <- x.df
diy.df$y <- y

## First step is to e stimate g

X <- diy.df %>% dplyr::select(c(x1, x2))
z <- -log(diy.df$y)
g.fn.est <- matsuoka.frontier::estimate.g(X, z)

## Then, estimate p

res <- z - g.fn.est$estimate
p.est <- matsuoka.frontier::estimate.p(res)

## Then, estimate f hat

f.fn.est <- matsuoka.frontier::estimate.frontier(g.fn.est$estimate, p.est)

ef <- y / f.fn.est
summary(ef)
print(p.est)
```
---
title: "MatsuokaDistribution"
output: rmarkdown::pdf_document
description: Learn how to use "MatsuokaDistribution" class object to estimate the production frontier using the three-step approach
vignette: >
  %\VignetteIndexEntry{MatsuokaDistribution}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}

---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Summary

In this vignette, it is presented several use cases demonstrating the functionality of the `matsuoka.frontier` package.

The examples below illustrate different ways to estimate the production frontier using the three-step approach:

1. Pre-mounted `g(.)` estimation methods
2. Method with specific arguments
3. Method with custom `g(.)` estimative
4. Without using the wrapper `matsuoka3step`
5. Cramer-Von Mises test with the Matsuoka's distribution after estimating Matsuoka parameter

## Setup for package use

```{r setup}
devtools::load_all()
library(matsuoka.frontier)
library(ggplot2)
library(Benchmarking)

data(milkProd)

N=nrow(milkProd)                #N=108
nc=milkProd$cows                #n cows
xc1=milkProd$vet/nc             #vet. expenses per cow (X)
x1=(xc1-min(xc1))/(max(xc1)-min(xc1))   #normalization 
xc2=milkProd$energy/nc          #energy expenses per cow (X)
x2=(xc2-min(xc2))/(max(xc2)-min(xc2))   #normalization
X=cbind(x1,x2)

y <- milkProd$milk/nc/10^3 
```

## Pre-mounted `g(.)` estimation methods

```{r premounted}
x.df <- as.data.frame(X)
res <- matsuoka.frontier::matsuoka3step(x = x.df, y = y, g = "gam")
```

This generates the `matsuoka3step` class object.

The default non-parametric function that estimates `g(.)` is set to the `gam` function.
It's possible to diagnose the `g(.)` function estimation through hierarchical built-in functions.

For example, the diagnose the default parameter `g(.)` function estimation can be done using `summary` and `plot`. This works, because `gam` has this built-in in it's class.

For example:
```{r gam diagnose}
summary(
  res$g_hat$model
)

plot(
  res$g_hat$model
)
```

The package does not have an automated plot function to extract `g(x)` components. However, since the `matsuoka3step` saves the `g(x)` estimated object, it is possible to extract the components through it, and diagnose each case, in our example case, we can:

```{r}
x1 <- res$x$x1
x2 <- res$x$x2
p_hat <- res$p_hat

pred_1 <- predict(res$g_hat$model,
                  newdata = data.frame(x1 = x1, x2 = median(x2)), type = "response")
pred_2 <- predict(res$g_hat$model,
                  newdata = data.frame(x1 = median(x1), x2 = x2), type = "response")

comp_1 <- exp((3 / (2 * p_hat)) - pred_1)
comp_2 <- exp((3 / (2 * p_hat)) - pred_2)

plot(x1, y, ylim = c(4,10))
lines(sort(x1), comp_1[order(x1)], col = "blue", lwd = 2)
plot(x2, y, ylim = c(4,10))
lines(sort(x2), comp_2[order(x2)], col = "red", lwd = 2)
```


After diagnosing the `g(.)` function, we can forward to the production frontier estimation diagnostics.
There is a built-in plot function that can be used, for example:
```{r gam mat plot 1}
plot(res, which = 1)
```

```{r gam mat plot 2}
plot(res, ngrid = 200, counter_levels = 15, which = 2)
```

And also a summary built-in function that provides further insights on the estimation, such as efficiency scores and percentage of efficiency scores higher than one.

```{r}
summary(res)
```

## Method with specific arguments

The `matsuoka3step` estimation function inherits properties from S3 objects, such as three dots that can be used for the estimation of `g(x)`.

```{r specific}
res.specific.gam <- matsuoka.frontier::matsuoka3step(x = x.df, y = y, g = "gam",
                                        family = "gaussian",
                                        method = "NCV",
                                        optimizer = "efs")
summary(res.specific.gam)

res.specific.spline <- matsuoka.frontier::matsuoka3step(x = as.data.frame(x.df$x1),
                                                        y = y, g ="spline",
                                                        lambda = 5,
                                                        all.knots = TRUE,
                                                        penalty = 0.95)

summary(res.specific.spline)

res.specific.sback <- matsuoka.frontier::matsuoka3step(x = x.df,
                                                       y = y,
                                                       g = "sback",
                                                       KfoldCV = 30,
                                                       kbin = 60)

summary(res.specific.sback)
```

## Method with custom `g(.)` estimative

Finally, there's the possibility to apply a customizable function from the user

```{r custom}
custom_fun <- function(X, z, ...) {
    list(estimate = rep(mean(z), nrow(X)))
}

res.custom.fn <- matsuoka.frontier::matsuoka3step(x = x.df, y = y, g = custom_fun)
res.custom.fn$f_hat <- round(res.custom.fn$f_hat, 2)

summary(res.custom.fn)
plot(res.custom.fn)
```

## Without using the wrapper `matsuoka3step`

There's also the possibility to mount your own matsuoka three step approach, given that primary functions are being publicly exported

```{r diy}
diy.df <- x.df
diy.df$y <- y

## First step is to e stimate g

X <- as.data.frame(cbind(diy.df$x1, diy.df$x2))
z <- -log(diy.df$y)
g.fn.est <- matsuoka.frontier::estimate.g(X, z)

## Then, estimate p

res <- z - g.fn.est$estimate
p.est <- matsuoka.frontier::estimate.p(res)

## Then, estimate f hat

f.fn.est <- matsuoka.frontier::estimate.frontier(g.fn.est$estimate, p.est)

ef <- y / f.fn.est
summary(ef)
print(p.est)
```

## Cramer-Von Mises test with the Matsuoka's distribution after estimating Matsuoka parameter

To a better diagnose of the Matsuoka's distribuition, in this library it was also implemented the Cramer-von Mises test to verify adherence of the estimate `p`:

```{r}
set.seed(1234)

x.t <- rmv(100, 8.3)
res <- matsuoka.frontier::matsuoka3step(x = x.df, y = y, g = "backf.cl", 
                                        windows = c(1,1))
cvm_matsuoka_test(x.t, p = res$p_hat)
```

And finally, a visual plot to compare:
```{r}
visual_cvm_matsuoka(x.t, p = res$p_hat, nullname = "test")
```

